From 3cd0ed1ac2768b40307ed043e7ba36cbae511bef Mon Sep 17 00:00:00 2001
From: Yuta Saito <kateinoigakukun@gmail.com>
Date: Mon, 31 Oct 2022 11:07:57 +0000
Subject: [PATCH] openssl: Undefine `SSLContext#servername_cb` and
 `OpenSSL::Session` for no socket platforms

This fixes a linkage error on platforms which do not have socket, like
WASI.
---
 ext/openssl/ossl_ssl.c         | 6 ++++++
 ext/openssl/ossl_ssl_session.c | 6 ++++++
 2 files changed, 12 insertions(+)

diff --git a/ext/openssl/ossl_ssl.c b/ext/openssl/ossl_ssl.c
index 478ff869a4..65a8d35acd 100644
--- a/ext/openssl/ossl_ssl.c
+++ b/ext/openssl/ossl_ssl.c
@@ -554,6 +554,7 @@ ossl_sslctx_add_extra_chain_cert_i(RB_BLOCK_CALL_FUNC_ARGLIST(i, arg))
 
 static VALUE ossl_sslctx_setup(VALUE self);
 
+#ifndef OPENSSL_NO_SOCK
 static VALUE
 ossl_call_servername_cb(VALUE ary)
 {
@@ -620,6 +621,7 @@ ssl_renegotiation_cb(const SSL *ssl)
 
     rb_funcallv(cb, id_call, 1, &ssl_obj);
 }
+#endif
 
 static VALUE
 ssl_npn_encode_protocol_i(RB_BLOCK_CALL_FUNC_ARGLIST(cur, encoded))
@@ -742,6 +744,7 @@ ssl_alpn_select_cb(SSL *ssl, const unsigned char **out, unsigned char *outlen,
     return ssl_npn_select_cb_common(ssl, cb, out, outlen, in, inlen);
 }
 
+#ifndef OPENSSL_NO_SOCK
 /* This function may serve as the entry point to support further callbacks. */
 static void
 ssl_info_cb(const SSL *ssl, int where, int val)
@@ -752,6 +755,7 @@ ssl_info_cb(const SSL *ssl, int where, int val)
 	ssl_renegotiation_cb(ssl);
     }
 }
+#endif
 
 /*
  * Gets various OpenSSL options.
@@ -953,11 +957,13 @@ ossl_sslctx_setup(VALUE self)
 	OSSL_Debug("SSL SESSION remove callback added");
     }
 
+#ifndef OPENSSL_NO_SOCK
     val = rb_attr_get(self, id_i_servername_cb);
     if (!NIL_P(val)) {
         SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
 	OSSL_Debug("SSL TLSEXT servername callback added");
     }
+#endif
 
 #if OPENSSL_VERSION_NUMBER >= 0x10101000 && !defined(LIBRESSL_VERSION_NUMBER)
     /*
diff --git a/ext/openssl/ossl_ssl_session.c b/ext/openssl/ossl_ssl_session.c
index 92eb1365fe..12f062701f 100644
--- a/ext/openssl/ossl_ssl_session.c
+++ b/ext/openssl/ossl_ssl_session.c
@@ -21,6 +21,7 @@ const rb_data_type_t ossl_ssl_session_type = {
     0, 0, RUBY_TYPED_FREE_IMMEDIATELY,
 };
 
+#ifndef OPENSSL_NO_SOCK
 static VALUE ossl_ssl_session_alloc(VALUE klass)
 {
 	return TypedData_Wrap_Struct(klass, &ossl_ssl_session_type, NULL);
@@ -299,6 +300,7 @@ static VALUE ossl_ssl_session_to_text(VALUE self)
 	return ossl_membio2str(out);
 }
 
+#endif /* !defined(OPENSSL_NO_SOCK) */
 
 void Init_ossl_ssl_session(void)
 {
@@ -310,6 +312,9 @@ void Init_ossl_ssl_session(void)
 	cSSLSession = rb_define_class_under(mSSL, "Session", rb_cObject);
 	eSSLSession = rb_define_class_under(cSSLSession, "SessionError", eOSSLError);
 
+#ifdef OPENSSL_NO_SOCK
+        rb_define_method(cSSLSession, "initialize", rb_f_notimplement, -1);
+#else
 	rb_define_alloc_func(cSSLSession, ossl_ssl_session_alloc);
 	rb_define_method(cSSLSession, "initialize", ossl_ssl_session_initialize, 1);
 	rb_define_method(cSSLSession, "initialize_copy", ossl_ssl_session_initialize_copy, 1);
@@ -324,4 +329,5 @@ void Init_ossl_ssl_session(void)
 	rb_define_method(cSSLSession, "to_der", ossl_ssl_session_to_der, 0);
 	rb_define_method(cSSLSession, "to_pem", ossl_ssl_session_to_pem, 0);
 	rb_define_method(cSSLSession, "to_text", ossl_ssl_session_to_text, 0);
+#endif /* OPENSSL_NO_SOCK */
 }
-- 
2.36.1

